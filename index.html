<!DOCTYPE html>
<html lang="en">
<!-- note: modified simple.css to comment out webfont loading -->
    <head>
        <meta charset="utf-8">

        <title>RR-TM</title>
        <link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/simple.css" id="theme">    
		<!--Add support for earlier versions of Internet Explorer -->
		<!--[if lt IE 9]>
			<script src="lib/js/html5shiv.js"></script>
	    <![endif]-->

		<link rel="stylesheet" href="styles/default.css">
		<script src="highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>

        <script src="raphael-min.js"></script>
        <style media="screen">
            body {
                margin: 0;
                padding: 0;
                text-align: center;
            }
            h1 {
                font-weight: 400;
                height: 5%;
	    }
	    .reveal h1 {
	        margin-bottom: 60px;
	        font-size: 60px;
            }
	    .reveal p {
	        text-align:left;
	    }
            #canvas {
                height: 480px;
                margin: 0 auto;
                text-align: left;
                width: 640px;
            }
            #code {
                font-family: Consolas, Monaco, "Lucida Console", monospace;
                height: 4em;
                margin: 10px;
                padding: 0;
                width: 90%;
            }
            #run {
                font-size: 2em;
            }
        </style>
    </head>
    <body>
        <div class="reveal">
          <div class="slides">
<!--------------------------------------------->
	  <section>
           <h1 style="font-size:58px">RR-TM: Improving Concurrency for<br> Eager Software Transactional Memory</h1>
           <p style="text-align:center">Gaurav Jain and Patrick Lam</p>
           <p style="text-align:center">University of Waterloo</p>
		   <p style="text-align:center">December 2, 2013</p>
	  </section>
<!--------------------------------------------->

          <section>
           <h1>Situation</h1>
           <p><div id="linked-list"></div></p>
           <div>
             <div>
	       <pre><code data-trim><!--  <span class="fragment">atomic </span>-->  {
    process(n4);
  }</code></pre>
	     </div>
             <div class="fragment">
               <p>implies the following operations:</p>
	       <div>
		 <pre><code data-trim>  <!--atomic -->{
    READ head
    READ n1.next
    READ n2.next
    READ n3.next
    process(n4)
  }</code></pre>
	       </div>
	     </div>
	   </div>
          </section>
<!--------------------------------------------->

          <section>
           <h1>Contention</h1>

	   <p>Let's add atomic blocks...<br>
            <span class="fragment" style="padding-left:2em" data-fragment-index="2">... and throw in a TM_WRITE.</span></p>
	    <div style="display:inline-block; width:10em" class="fragment" data-fragment-index="2">
              <pre><code class="ruby">
  atomic {
    TM_WRITE n1.next
  }
	      </code></pre>
	    </div>
	    <div style="display:inline-block; width:10em">
              <pre><code>
<span class="fragment" data-fragment-index="1"> atomic { </span>
    TM_READ head
    TM_READ n1.next
    TM_READ n2.next
    TM_READ n3.next
    process(n4)
<span class="fragment" data-fragment-index="1">   } </span>
	      </code></pre>
	    </div>

<p>Now what?</p>
          </section>
<!--------------------------------------------->

          <section>
	    <h1>Aside: Eager vs lazy STM</h1>

	    <table>
	      <tr><td></td><th>Eager</th><th>Lazy</th></tr>
	      <tr><td style="padding-right:1em">TM_WRITE</td><td style="padding-right:1em">write memory directly&nbsp;&amp;</td><td>buffer the write</td></tr>
	      <tr><td></td><td><c style="padding-right:0.5em"></c>buffer old value</td></tr>
	      <tr><td>TM_READ</td><td>read memory directly</td><td>read memory directly</td></tr>
	    </table>
	  </section>

<!--------------------------------------------->

          <section>
           <h1>Handling the WRITE</h1>

	   <p>Let's throw in a WRITE.</p>
	    <div style="display:inline-block; width:10em">
              <pre><code class="ruby">
  atomic {
    TM_WRITE n1.next
  }
	      </code></pre>
	    </div>
	    <div style="display:inline-block; width:10em">
              <pre><code>
  atomic {
    TM_READ head
    TM_READ n1.next
    TM_READ n2.next
    TM_READ n3.next
    process(n4)
  }
	      </code></pre>
	    </div>
	    <p style="margin-top:1em" class="reveal">If TM_WRITE runs first, TM_READer must stall or abort.</p>

          </section>
<!--------------------------------------------->

          <section>
           <h1>Key idea: reservations and releases</h1>

	   <p style="padding-bottom:0.5em">We introduce the notions of <em>reservations</em> and <em>releases</em>.</p>
	   
	   <ul>
	     <li>Reservations secure access to memory.</li>
	     <li>Releases allow others to access memory.</li>
	   </ul>

	  </section>

<!--------------------------------------------->

          <section>
	    <section>
              <h1>Memory reservations</h1>
	      
	      <p style="padding-bottom:1em">Recall: a TM_WRITE locks out readers until it commits or aborts.<br>
		Implication: subsequent accesses need not go through runtime.</p>
	      
	      <p>Two types of reservations: write and read.</p>
	    </section>

<!--------------------------------------------->

            <section>
              <h1>Write reservations</h1>


	      <p>A <em>write reservation</em> locks out readers, without an actual write.</p>
	      <ul>
		<li>Can be done ahead of time, before the access.</li>
	      </ul>

	      <div style="display:inline-block; width:11em">
		<pre><code class="ruby">
  atomic {
    TM_WRITE_RESERVE n1.next
    n1.next = null
  }
		</code></pre>
	      </div>
	      <div style="display:inline-block; width:13.5em">
		<pre><code class="ruby C">
  atomic {
    TM_READ head
    TM_READ n1.next  # stall or abort
  }
		</code></pre>
	      </div>

	      <p>After a write reserve, a thread may directly write to memory.</p>
	      
            </section>

<!--------------------------------------------->
            <section>
              <h1>Read reservations</h1>

	      <p>Similarly, a <em>read reservation</em> prevents concurrent writes,<br>
	         enabling direct reads.</p>

	      <div style="display:inline-block; width:13.5em">
		<pre><code class="ruby C">
  atomic {
    TM_READ_RESERVE head
    x = head
    ...
    y = head
  }
		</code></pre>
	      </div>
	      <p style="margin-bottom:1em">Transactions may concurrently read reserve an address.</p>
	      <p>Writers must stall or abort.</p>

	    </section>

<!--------------------------------------------->
	    <section>
	      <h1>Implications of reservations</h1>

	      <p>Enable unmediated access to memory.</p>
	      <ul style="margin-bottom:1em">
	      <li>Eliminate overhead due to TM_READ, TM_WRITE calls.</li>
	      <li>Especially useful for repeated re-reads in a loop.</li>
	      </ul>
	      <p>Path-sensitive compiler analyses can use reservations to optimize code.</p>
	    </section>

	  </section>

<!--------------------------------------------->
<!--------------------------------------------->

          <section>
	    <section>
              <h1>Memory releases</h1>
	      
	      <p style="padding-bottom:1em">As seen until now, reservations persist until commit or abort.</p>
	      
	      <p>A <em>release</em> signals that a transaction is done with an address.</p>
	      <ul style="margin-bottom:1em">
	      <li>Only applicable to read reservations.</li>
	      <li>Allows other threads to write the address.</li>
	      </ul>
	    </section>

<!--------------------------------------------->
	    <section>
              <h1>Memory release example</h1>

		<pre><code class="ruby C">
  atomic {
    {
      Node n = TM_READ head->next
      TM_READ_RESERVE n
      # access n directly and repeatedly
      TM_RELEASE n

      # n goes out of scope
    }
    # more processing, but no more accesses to n
  }
		</code></pre>

	    </section>
<!--------------------------------------------->
	    <section>
              <h1>Regaining access after a release</h1>

	      <p style="margin-bottom:1em">A transaction may regain access to an address after releasing it.</p>

		<pre><code class="ruby C">  atomic {
    Node n = TM_READ head->next
    TM_READ_RESERVE n
    # access n directly and repeatedly
    TM_RELEASE n

    # ...

    TM_READ_RESERVE n
  }</code></pre>

	      <p>If another transaction reserved the address meanwhile, <br> 
             <span style="padding-right:1em">&nbsp;</span> re-reader must abort.</p>
	    </section>

<!--------------------------------------------->

	    <section>
              <h1>Reservations and releases <br> reduce instrumentation</h1>

	      <div style="display:inline-block; width:13em">
		<pre><code class="C">int a, b, c, d;

int bar(int& x) {
 return TM_READ(&x)+1;
}

int foo() {
 TM_WRITE(&a, 2);
 TM_WRITE(&b, 2);
 if (TM_READ(&d) >= 0) {
  TM_WRITE(&b, TM_READ(&c) + 
                 TM_READ(&d));
 } else {
  TM_WRITE(&a, bar(b));
 }
 return TM_READ(&a) + TM_READ(&b);
}		</code></pre>
	      </div>
	      <div style="display:inline-block; width:13.2em">
		<pre><code class="C">int a, b, c, d;

int bar(int& x) { return x+1; }

int foo() {
 TM_WRITE_RESERVE(&a);
 TM_WRITE_RESERVE(&b);
 bool release = TM_READ_RESERVE(&d);
 if (d > 0) {
  a = 2;
  b = TM_READ_RELEASE(&c) + d;
 } else {
  b = 2; a = bar(b);
 }
 if (release)
  TM_RELEASE(&d);
 return a + b; }</code></pre>
	      </div>

	    </section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->
      <section>
		<section>
          <h1>Implications of reserves and releases</h1>

	      <p>Motivating observation:</p>
		  <ul style="margin-bottom:1em"> <li> Large read sets often stall writers.</li> </ul>
		  
	      <p style="margin-bottom:1em">Our Goal: minimize writer lock-out.</p>
		  
	      <p>Reserves and releases, together, allow temporary privatization of memory.</p>
		  
	      <p>Mechanism: commit-time validation and reader aborts.</p>
		</section>

<!--------------------------------------------->
		<section>
          <h1>Privatization</h1>

		</section>

<!--------------------------------------------->
		<section>
          <h1>Optimizations That RR-TM Enables</h1>

		  <ul> 
			<li> write demotions </li>
			<li> reserve dependencies </li>
		  </ul>
		</section>

		<section>
          <h1>RR-TM Optimizations</h1>

		</section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->

	  </div>
	  </div>

	  <script src="lib/js/head.min.js"></script>
	  <script src="js/reveal.min.js"></script>
        <script>
/* from graffle.js example */
Raphael.fn.connection = function (obj1, obj2, line, bg) {
    if (obj1.line && obj1.from && obj1.to) {
        line = obj1;
        obj1 = line.from;
        obj2 = line.to;
    }
    var bb1 = obj1.getBBox(),
        bb2 = obj2.getBBox(),
        p = [{x: bb1.x + bb1.width / 2, y: bb1.y - 1},
        {x: bb1.x + bb1.width / 2, y: bb1.y + bb1.height + 1},
        {x: bb1.x - 1, y: bb1.y + bb1.height / 2},
        {x: bb1.x + bb1.width + 1, y: bb1.y + bb1.height / 2},
        {x: bb2.x + bb2.width / 2, y: bb2.y - 1},
        {x: bb2.x + bb2.width / 2, y: bb2.y + bb2.height + 1},
        {x: bb2.x - 1, y: bb2.y + bb2.height / 2},
        {x: bb2.x + bb2.width + 1, y: bb2.y + bb2.height / 2}],
        d = {}, dis = [];
    for (var i = 0; i < 4; i++) {
        for (var j = 4; j < 8; j++) {
            var dx = Math.abs(p[i].x - p[j].x),
                dy = Math.abs(p[i].y - p[j].y);
            if ((i == j - 4) || (((i != 3 && j != 6) || p[i].x < p[j].x) && ((i != 2 && j != 7) || p[i].x > p[j].x) && ((i != 0 && j != 5) || p[i].y > p[j].y) && ((i != 1 && j != 4) || p[i].y < p[j].y))) {
                dis.push(dx + dy);
                d[dis[dis.length - 1]] = [i, j];
            }
        }
    }
    if (dis.length == 0) {
        var res = [0, 4];
    } else {
        res = d[Math.min.apply(Math, dis)];
    }
    var x1 = p[res[0]].x,
        y1 = p[res[0]].y,
        x4 = p[res[1]].x,
        y4 = p[res[1]].y;
    dx = Math.max(Math.abs(x1 - x4) / 2, 10);
    dy = Math.max(Math.abs(y1 - y4) / 2, 10);
    var x2 = [x1, x1, x1 - dx, x1 + dx][res[0]].toFixed(3),
        y2 = [y1 - dy, y1 + dy, y1, y1][res[0]].toFixed(3),
        x3 = [0, 0, 0, 0, x4, x4, x4 - dx, x4 + dx][res[1]].toFixed(3),
        y3 = [0, 0, 0, 0, y1 + dy, y1 - dy, y4, y4][res[1]].toFixed(3);
    var path = ["M", x1.toFixed(3), y1.toFixed(3), "C", x2, y2, x3, y3, x4.toFixed(3), y4.toFixed(3), 
                "L", (x4 - res[1]*3).toFixed(3), (y4 - res[1]*1.5).toFixed(3),
                "M", x4.toFixed(3), y4.toFixed(3),
                "L", (x4 - res[1]*3).toFixed(3), (y4 + res[1]*1.5).toFixed(3)].join(",");
    if (line && line.line) {
        line.bg && line.bg.attr({path: path});
        line.line.attr({path: path});
    } else {
        var color = typeof line == "string" ? line : "#fff";
        return {
            bg: bg && bg.split && this.path(path).attr({stroke: bg.split("|")[0], fill: "none", "stroke-width": bg.split("|")[1] || 3}),
            line: this.path(path).attr({stroke: color, fill: "none"}),
            from: obj1,
            to: obj2
        };
    }
};

var el;
window.onload = function () {
    var r = Raphael("linked-list", 640, 100),
        connections = [],
        labels = [],
        shapes = [];
    for (var i = 0; i < 4; i++) {
        labels.push(r.text(i*150+75, 50, "n"+(i+1).toString()).attr({"font-size": 20}));
        shapes.push(r.ellipse(i*150+75, 50, 20, 20));
        if (i > 0) connections.push(r.connection(shapes[i-1], shapes[i], "#000"));
    }
    connections.push(r.connection(r.path(["M", 0, 50]), shapes[0], "#000"));
};

// reveal
Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable touch events for navigation
        touch: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: false,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Transition style
        transition: 'none', // default/cube/page/concave/zoom/linear/fade/none

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page backgrounds
        backgroundTransition: 'default' // default/linear/none

});
        </script>
 
    </body>
</html>
