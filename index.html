<!DOCTYPE html>
<html lang="en">
<!-- note: modified simple.css to comment out webfont loading -->
    <head>
        <meta charset="utf-8">

        <title>RR-TM</title>
        <link rel="stylesheet" href="css/reveal.min.css">
		<link rel="stylesheet" href="css/theme/simple.css" id="theme">    
		<!--Add support for earlier versions of Internet Explorer -->
		<!--[if lt IE 9]>
			<script src="lib/js/html5shiv.js"></script>
	    <![endif]-->

		<link rel="stylesheet" href="styles/default.css">
		<script src="highlight.pack.js"></script>
		<script>hljs.initHighlightingOnLoad();</script>

        <script src="raphael-min.js"></script>
        <style media="screen">
            body {
                margin: 0;
                padding: 0;
                text-align: center;
            }
            h1 {
                font-weight: 400;
                height: 5%;
	    }
	    .reveal h1 {
	        margin-bottom: 60px;
	        font-size: 60px;
            }
	    .reveal p {
	        text-align:left;
	    }
            #canvas {
                height: 480px;
                margin: 0 auto;
                text-align: left;
                width: 640px;
            }
            #code {
                font-family: Consolas, Monaco, "Lucida Console", monospace;
                height: 4em;
                margin: 10px;
                padding: 0;
                width: 90%;
            }
            #run {
                font-size: 2em;
            }
        </style>
    </head>
    <body>
        <div class="reveal">
          <div class="slides">
<!--------------------------------------------->
	  <section>
           <h1 style="font-size:58px">RR-TM: Improving Concurrency for<br> Eager Software Transactional Memory</h1>
           <p style="text-align:center">Gaurav Jain and Patrick Lam</p>
           <p style="text-align:center">University of Waterloo</p>
		   <p style="text-align:center">December 2, 2013</p>
	  </section>
<!--------------------------------------------->

          <section>
           <h1>Situation</h1>
           <p><div id="linked-list"></div></p>
           <div>
             <div>
	       <pre><code data-trim><!--  <span class="fragment">atomic </span>-->  {
    process(n4);
  }</code></pre>
	     </div>
             <div class="fragment">
               <p>implies the following operations:</p>
	       <div>
		 <pre><code data-trim>  <!--atomic -->{
    READ head
    READ n1.next
    READ n2.next
    READ n3.next
    process(n4)
  }</code></pre>
	       </div>
	     </div>
	   </div>
          </section>
<!--------------------------------------------->

          <section>
           <h1>Contention</h1>

	   <p>Let's add atomic blocks...<br>
            <span class="fragment" style="padding-left:2em" data-fragment-index="2">... and throw in a TM_WRITE.</span></p>
	    <div style="display:inline-block; width:10em" class="fragment" data-fragment-index="2">
              <pre><code class="ruby">  atomic {
    TM_WRITE n1.next
  }	      </code></pre>
	    </div>
	    <div style="display:inline-block; width:10em">
              <pre><code><span class="fragment" data-fragment-index="1"> atomic { </span>
    TM_READ head
    TM_READ n1.next
    TM_READ n2.next
    TM_READ n3.next
    process(n4)
<span class="fragment" data-fragment-index="1">   } </span>	      </code></pre>
	    </div>

<p class="fragment" data-fragment-index="2">Transactions guarantee <em>isolation</em> and <em>serializability</em>.</p>
          </section>
<!--------------------------------------------->

          <section>
	    <h1>Eager vs lazy STM</h1>

		<p style="margin-bottom:1em">Two ways to implement transactions.</p>

	    <table style="font-size:smaller; padding-left:3em">
	      <tr><td></td><th>Eager</th><th>Lazy</th></tr>
	      <tr><td style="padding-right:3em">TM_WRITE</td><td style="padding-right:3em">write memory directly&nbsp;&amp;</td><td>buffer the write</td></tr>
	      <tr><td></td><td><c style="padding-right:1em"></c>remember old value</td></tr>
	      <tr><td>TM_READ</td><td>read memory directly</td><td>read memory indirectly</td></tr>
		  <tr><td></td><td></td><td>&nbsp;&nbsp; (using buffered values)</td></tr>
	    </table>
	  </section>

<!--------------------------------------------->

          <section>
           <h1>Handling the WRITE</h1>

	    <div style="display:inline-block; width:10em">
              <pre><code class="ruby">  atomic {
    TM_WRITE n1.next
  }	      </code></pre>
	    </div>
	    <div style="display:inline-block; width:10em">
              <pre><code>  atomic {
    TM_READ head
    TM_READ n1.next
    TM_READ n2.next
    TM_READ n3.next
    process(n4)
  }	      </code></pre>
	    </div>
	    <p style="margin-top:1em" class="reveal">If TM_WRITE runs first, TM_READer must stall or abort.</p>

          </section>
<!--------------------------------------------->

          <section>
           <h1>Our key idea: reservations and releases</h1>

	   <p style="padding-bottom:0.5em">We introduce the notions of <em>reservations</em> and <em>releases</em>.</p>
	   
	   <ul>
	     <li>Reservations secure access to memory.</li>
	     <li>Releases allow others to access memory.</li>
	   </ul>

	  </section>

<!--------------------------------------------->

          <section>
	    <section>
              <h1>Memory reservations</h1>
	      
	      <p style="padding-bottom:1em">Recall: a TM_WRITE locks out readers until it commits or aborts.<br>
		Implication: subsequent accesses need not go through runtime.</p>

		  <p style="padding-bottom:1em">Reservations perform the lockout without an actual access.</p>

		  <figure style="padding-bottom:1em">
		  <img src="images/Lockout-tagout_hasp.svg" alt="lockout/tagout"> <figcaption style="font-size:smaller">(wikimedia, RTCNCA)</figcaption>
		  </figure>
	      
	      <p>Two types of reservations: write and read.</p>
	    </section>

<!--------------------------------------------->

            <section>
              <h1>Write reservations</h1>


	      <p>A <em>write reservation</em> locks out readers, without an actual write.</p>
	      <ul>
		<li>Can be done ahead of time, before the access.</li>
	      </ul>

	      <div style="display:inline-block; width:11em">
		<pre><code class="ruby">
  atomic {
    TM_WRITE_RESERVE n1.next
    n1.next = null
  }
		</code></pre>
	      </div>
	      <div style="display:inline-block; width:13.5em">
		<pre><code class="ruby C">
  atomic {
    TM_READ head
    TM_READ n1.next  # stall or abort
  }
		</code></pre>
	      </div>

	      <p>After a write reserve, a thread may directly write to memory.</p>
	      
            </section>

<!--------------------------------------------->
            <section>
              <h1>Read reservations</h1>

	      <p>Similarly, a <em>read reservation</em> prevents concurrent writes,<br>
	         enabling direct reads.</p>

	      <div style="display:inline-block; width:13.5em">
		<pre><code class="ruby C">
  atomic {
    TM_READ_RESERVE head
    x = head
    ...
    y = head
  }
		</code></pre>
	      </div>
	      <p style="margin-bottom:1em">Transactions may concurrently read reserve an address.</p>
	      <p>Writers must stall or abort.</p>

	    </section>

<!--------------------------------------------->
	    <section>
	      <h1>Implications of reservations</h1>

	      <p>Enable unmediated access to memory.</p>
	      <ul style="margin-bottom:1em">
	      <li>Eliminate overhead due to TM_READ, TM_WRITE calls.</li>
	      <li>Especially useful for repeated re-reads in a loop.</li>
	      </ul>
	      <p>Path-sensitive compiler analyses can use reservations to optimize code.</p>
	    </section>

	  </section>

<!--------------------------------------------->
<!--------------------------------------------->

          <section>
	    <section>
              <h1>Memory releases</h1>
	      
	      <p style="padding-bottom:1em">As seen until now, reservations persist until commit or abort.</p>
	      
	      <p>A <em>release</em> signals that a transaction is done with an address.</p>
	      <ul style="margin-bottom:1em">
	      <li>Only applicable to read reservations.</li>
	      <li>Allows other threads to write the address.</li>
	      </ul>
	    </section>

<!--------------------------------------------->
	    <section>
              <h1>Memory release example</h1>

		<pre><code class="ruby C">
  atomic {
    {
      Node n = TM_READ head->next
      TM_READ_RESERVE n
      # access n directly and repeatedly
      TM_RELEASE n

      # n goes out of scope
    }
    # more processing, but no more accesses to n
  }
		</code></pre>

	    </section>
<!--------------------------------------------->
	    <section>
              <h1>Regaining access after a release</h1>

	      <p style="margin-bottom:1em">A transaction may regain access to an address after releasing it.</p>

		<pre><code class="ruby C">  atomic {
    Node n = TM_READ head->next
    TM_READ_RESERVE n
    # access n directly and repeatedly
    TM_RELEASE n

    # ...

    TM_READ_RESERVE n
  }</code></pre>

	      <p>If another transaction reserved the address meanwhile, <br> 
             <span style="padding-right:1em">&nbsp;</span> re-reader must abort.</p>
	    </section>

<!--------------------------------------------->

	    <section>
              <h1>Reservations and releases <br> reduce instrumentation</h1>

	      <div style="display:inline-block; width:13em">
		<pre><code class="C">int a, b, c, d;

int bar(int& x) {
 return TM_READ(&x)+1;
}

int foo() {
 TM_WRITE(&a, 2);
 TM_WRITE(&b, 2);
 if (TM_READ(&d) >= 0) {
  TM_WRITE(&b, TM_READ(&c) + 
                 TM_READ(&d));
 } else {
  TM_WRITE(&a, bar(b));
 }
 return TM_READ(&a) + TM_READ(&b);
}		</code></pre>
	      </div>
	      <div style="display:inline-block; width:13.2em">
		<pre><code class="C">int a, b, c, d;

int bar(int& x) { return x+1; }

int foo() {
 TM_WRITE_RESERVE(&a);
 TM_WRITE_RESERVE(&b);
 bool release = TM_READ_RESERVE(&d);
 if (d > 0) {
  a = 2;
  b = TM_READ_RELEASE(&c) + d;
 } else {
  b = 2; a = bar(b);
 }
 if (release)
  TM_RELEASE(&d);
 return a + b; }</code></pre>
	      </div>

	    </section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->
      <section>
		<section>
          <h1>Implications of reserves and releases</h1>

	      <p>Motivating observation:</p>
		  <ul style="margin-bottom:1em"> <li> Large read sets often stall writers.</li> </ul>
		  
	      <p style="margin-bottom:1em">Our Goal: minimize writer lock-out.</p>
		  
		</section>

<!--------------------------------------------->
		<section>
		  <h1>Privatization</h1>
		  <p>Reserves and releases, together, allow temporary privatization of memory.</p>		  
		  
		  
		  <p>Mechanism: commit-time validation and reader aborts.</p>

		  <p>A transaction can write to an address only if there are no active read reservations on an address.</p>

		  <p>If a transaction tries to write to a released address, writer commit only succeeds after all released readers have completed.</p>

		  <p>Writer ensures ordering by stalling until all readers commit or abort; or by aborting and rolling back</p>

		  <p>When a reader tries to re-read a previously read (and released) address, it must request a new reservation.</p>
		  <p>If the address has been subsequently write reserved, reader must abort.</p>

		</section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->
          <section>
            <section>
              <h1>RR-TM Enables Optimization</h1>

	      <p>Our novel API enable compilers to emit better code, using</p>
	      <ul> 
		<li> write demotions; and </li>
		<li> reserve dependencies. </li>
	      </ul>
	    </section>

	    <section>
              <h1>Reserve Dependencies</h1>

	      <p>Consider:</p>

		<pre><code>TM_WRITE_RESERVE(A)
# ...
TM_READ_RESERVE(B)</code></pre>

	      <p>Write reservation of A always precedes reservation of B.</p>
	      <ul>
	      <li>B's reservation succeeds iff A's write reserve succeeds.</li>
	      <li>We can eliminate reservation of B.</li>
	      </ul>
	      <p style="margin-bottom:1em">Bonus: no need for undo log tracking.</p>
	      <p>Reserve dependency optimization improved benchmark results.</p>

	      
	    </section>

	    <section>
              <h1>Write demotions</h1>
	      <p>Consider:</p>
		<pre><code># x already contains 5
TM_WRITE(x, 5);</code></pre>
	      <p>In this case, a <em>read reservation</em> suffices.</p>
	      <p>Our reserve API thus enables more concurrent access to x.</p>
	    </section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->
          <section>
            <section>
              <h1>Implementing RR-TM: Bytelocks</h1>

	      <p>Reservations and releases require extensions </p>
	      <p style="margin-left:1em">to underlying lock implementation.</p>
	      <p>We extended TLRW (implemented by RSTM).</p>
	      <p style="margin-bottom:1em">Lock implementation: byte-locks.</p>

	      <p style="font-size:smaller; margin-left:1em">(eager byte-locks, encounter-time locking upon access, free upon commit.)</p>

	    </section>
            <section>
              <h1>Bytelock data structure</h1>

	      <p>We redesigned bytelocks for our 64-hardware-thread system.</p>

	      <img src="images/bytelocks-highlight.png" style="border:0">
	      <p>(also, no unslotted threads)</p>
	      <aside class="notes">two cache lines, but only 1 for the byte array containing locks.</aside>

	    </section>

            <section>
              <h1 style="margin-bottom:.5em">Active Readers</h1>

	      <img src="images/bytelocks-active-readers.png" style="border:0; height:400px">

	      <p>Per-thread reserve &amp; release flags indicate <em>active readers</em>.</p>

	      <p>Reserve: thread is active, may perform privatized access.</p>
	      <p style="margin-bottom:1em">Release: thread no longer active, but not yet committed.</p>

	      <p>Writer uses per-lock released field to indicate acquisition.</p>

	    </section>

            <section>
              <h1>Acquiring a write reservation</h1>

	      <img src="images/bytelocks-write-reserve.png" style="border:0; height:400px">

	      <ol>
	      <li>Compare-and-swap to set owner field.</li>
	      <li>Clear own reserve and release flags.</li>
	      <li>Scan for any other active readers; stall until there are none.</li>
	      <li>If any release flags set, set the per-lock released field.</li>
	      </ol>

	    </section>

            <section>
              <h1>Write reservation: guarantees</h1>

	      <img src="images/bytelocks-write-reserve.png" style="border:0; height:400px">

	      <p>If you have a writer lock, <br><span style="margin-left:1em">no other transaction may read or write to that address.</span></p>
	      <p>Hence, you may freely modify that address<br> without additional instrumentation.</p>
	    </section>

            <section>
              <h1>Acquiring a read reservation</h1>
	      <img src="images/bytelocks-write-reserve.png" style="border:0; height:400px">

	      <ol>
	      <li>Atomically set own reserve flag.</li>
	      <li>Inspect per-lock owner field.</li>
	      <li>If lock held, and own release flag set, abort.</li>
	      <li>If lock held, and own release flag unset, <br><span style="padding-left:1em">clear reserve flag and retry.</span></li>
	      </ol>
	    </section>

            <section>
              <h1>Read reservation: guarantees</h1>

	      <img src="images/bytelocks-write-reserve.png" style="border:0; height:400px">

	      <p>Once you hold a reader lock,<br><span style="padding-left:1em"> contents are guaranteed to not change.</span></p>
	      <p>You may freely read locked address<br> without additional instrumentation.</p>

	    </section>

            <section>
              <h1>Performing a memory release</h1>
	      <img src="images/bytelocks-release.png" style="border:0; height:400px">

	      <p>You must hold active reader lock.</p>
	      <p>Set your release flag, clear your reserve flag.</p>
	    </section>

            <section>
              <h1>Committing a transaction</h1>
	    </section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->
          <section>
            <section>
              <h1>Results</h1>

	    </section>

<!--------------------------------------------->
            <section>
              <h1>Experimental Setup</h1>

	    </section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->
          <section>
            <section>
              <h1>Related Work: &ldquo;static&rdquo; reservations</h1>

	      <p>Initial work on STM [ST95] contained a notion of reservations:<br>
		<span style="margin-left:1em">must declare all accessed addresses upon transaction entry.</span></p>
	      <p>Such a notion was impractical for dynamic data structures.</p>
	      <p>Our notion is dynamic and applies to an eager system.</p>
	    </section>

            <section>
              <h1>Related Work: decomposing locks &amp; <br>accesses</h1>
	      <p>Notion of &ldquo;lock first, access later&rdquo; appears in [HP+96], [SA+06].</p>
	      <p>Our work focusses on eager STM &amp; uninstrumented accesses.</p>
	      <p>Also, we make stronger privatization guarantees at reservations.</p>
	    </section>

            <section>
              <h1>Related Work: DSTM releases</h1>
	      <p>Early releases first appeared in DSTM [HL+03].</p>
	      <p>Idea: remove addresses from the read set of a transaction.</p>
	      <p>These releases were manually inserted; domain knowledge ensured safety.</p>
	      <p style="margin-left:1em">e.g.: release parent nodes in a tree traversal.</p>
	      <p>No commit-time validation needed in DSTM.</p>
	    </section>
            <section>
              <h1>Related Work: DSTM vs RR-TM releases</h1>
	      <p>RR-TM releases could be mechanically applied,</p>
	      <p style="margin-left:1em">in tandem with reservations.</p>
	      <p>Applicable to any read; a transaction may re-reserve an address.</p>
	      <p>Requires commit-time validation.</p>
	    </section>

            <section>
              <h1>Related Work: privatization</h1>

	      <p>Originally from lock-based concurrency control.</p>
	      <p>Our contribution: </p>
	      <blockquote>explicit, domain-knowledge-free privatization through reservations and releases.</blockquote>
	    </section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->
          <section>
            <section>
              <h1>Conclusions</h1>
	    </section>

	  </section>
<!--------------------------------------------->
<!--------------------------------------------->


	  </div>
	  </div>

	  <script src="lib/js/head.min.js"></script>
	  <script src="js/reveal.min.js"></script>
        <script>
/* from graffle.js example */
Raphael.fn.connection = function (obj1, obj2, line, bg) {
    if (obj1.line && obj1.from && obj1.to) {
        line = obj1;
        obj1 = line.from;
        obj2 = line.to;
    }
    var bb1 = obj1.getBBox(),
        bb2 = obj2.getBBox(),
        p = [{x: bb1.x + bb1.width / 2, y: bb1.y - 1},
        {x: bb1.x + bb1.width / 2, y: bb1.y + bb1.height + 1},
        {x: bb1.x - 1, y: bb1.y + bb1.height / 2},
        {x: bb1.x + bb1.width + 1, y: bb1.y + bb1.height / 2},
        {x: bb2.x + bb2.width / 2, y: bb2.y - 1},
        {x: bb2.x + bb2.width / 2, y: bb2.y + bb2.height + 1},
        {x: bb2.x - 1, y: bb2.y + bb2.height / 2},
        {x: bb2.x + bb2.width + 1, y: bb2.y + bb2.height / 2}],
        d = {}, dis = [];
    for (var i = 0; i < 4; i++) {
        for (var j = 4; j < 8; j++) {
            var dx = Math.abs(p[i].x - p[j].x),
                dy = Math.abs(p[i].y - p[j].y);
            if ((i == j - 4) || (((i != 3 && j != 6) || p[i].x < p[j].x) && ((i != 2 && j != 7) || p[i].x > p[j].x) && ((i != 0 && j != 5) || p[i].y > p[j].y) && ((i != 1 && j != 4) || p[i].y < p[j].y))) {
                dis.push(dx + dy);
                d[dis[dis.length - 1]] = [i, j];
            }
        }
    }
    if (dis.length == 0) {
        var res = [0, 4];
    } else {
        res = d[Math.min.apply(Math, dis)];
    }
    var x1 = p[res[0]].x,
        y1 = p[res[0]].y,
        x4 = p[res[1]].x,
        y4 = p[res[1]].y;
    dx = Math.max(Math.abs(x1 - x4) / 2, 10);
    dy = Math.max(Math.abs(y1 - y4) / 2, 10);
    var x2 = [x1, x1, x1 - dx, x1 + dx][res[0]].toFixed(3),
        y2 = [y1 - dy, y1 + dy, y1, y1][res[0]].toFixed(3),
        x3 = [0, 0, 0, 0, x4, x4, x4 - dx, x4 + dx][res[1]].toFixed(3),
        y3 = [0, 0, 0, 0, y1 + dy, y1 - dy, y4, y4][res[1]].toFixed(3);
    var path = ["M", x1.toFixed(3), y1.toFixed(3), "C", x2, y2, x3, y3, x4.toFixed(3), y4.toFixed(3), 
                "L", (x4 - res[1]*3).toFixed(3), (y4 - res[1]*1.5).toFixed(3),
                "M", x4.toFixed(3), y4.toFixed(3),
                "L", (x4 - res[1]*3).toFixed(3), (y4 + res[1]*1.5).toFixed(3)].join(",");
    if (line && line.line) {
        line.bg && line.bg.attr({path: path});
        line.line.attr({path: path});
    } else {
        var color = typeof line == "string" ? line : "#fff";
        return {
            bg: bg && bg.split && this.path(path).attr({stroke: bg.split("|")[0], fill: "none", "stroke-width": bg.split("|")[1] || 3}),
            line: this.path(path).attr({stroke: color, fill: "none"}),
            from: obj1,
            to: obj2
        };
    }
};

var el;
window.onload = function () {
    var r = Raphael("linked-list", 640, 100),
        connections = [],
        labels = [],
        shapes = [];
    for (var i = 0; i < 4; i++) {
        labels.push(r.text(i*150+75, 50, "n"+(i+1).toString()).attr({"font-size": 20}));
        shapes.push(r.ellipse(i*150+75, 50, 20, 20));
        if (i > 0) connections.push(r.connection(shapes[i-1], shapes[i], "#000"));
    }
    connections.push(r.connection(r.path(["M", 0, 50]), shapes[0], "#000"));
};

// reveal
Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable touch events for navigation
        touch: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: false,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // Transition style
        transition: 'none', // default/cube/page/concave/zoom/linear/fade/none

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page backgrounds
        backgroundTransition: 'default' // default/linear/none

});
        </script>
 
    </body>
</html>
